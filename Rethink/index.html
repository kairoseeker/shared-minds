<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thought Weaver</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            color: #fff;
        }

        #canvas {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: grab;
            background-image: url('data:image/svg+xml,%3Csvg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"%3E%3Cg fill="%23222" fill-opacity="0.6" fill-rule="evenodd"%3E%3Ccircle cx="20" cy="20" r="1"/%3E%3C/g%3E%3C/svg%3E');
        }

        #line-container, #thought-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform-origin: 0 0;
        }

        thought-node {
            position: absolute;
            padding: 15px 25px;
            background-color: #333;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
            transition: box-shadow 0.3s ease, background-color 0.3s ease, color 0.3s ease;
            min-width: 100px;
            text-align: center;
            color: #ccc;
            pointer-events: all; /* Nodes themselves should be clickable */
        }

        thought-node:hover {
            box-shadow: 0 0 25px rgba(255,255,255,0.3);
        }

        thought-node.expanded, thought-node.main-thought {
            background-color: #fff;
            color: #000;
        }

        #permanent-input {
            position: absolute;
            display: none;
            padding: 12px;
            border: none;
            outline: none;
            background-color: #f0f0f0;
            color: #000;
            border-radius: 5px;
            font-family: 'Inter', sans-serif;
            font-size: 16px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 100;
            transform-origin: 0 0;
        }

        .line--parent-sub {
            stroke: #555;
            stroke-width: 2;
            stroke-dasharray: 4, 4;
            transition: stroke 0.3s ease;
        }

        .line--parent-parent {
            stroke: #fff;
            stroke-width: 2;
            transition: stroke 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="canvas">
        <!-- FIX: Swapped order. Lines now render *before* thoughts. -->
        <svg id="line-container"></svg>
        <div id="thought-container"></div>
    </div>
    <input type="text" id="permanent-input" />

    <script>
        // --- Web Component Definition ---
        class ThoughtNode extends HTMLElement {
            constructor() {
                super();
                this.thought = null; // Link back to the thought object
            }
        }
        customElements.define('thought-node', ThoughtNode);

        // --- Global State ---
        const canvas = document.getElementById('canvas');
        const thoughtContainer = document.getElementById('thought-container');
        const lineContainer = document.getElementById('line-container');
        const input = document.getElementById('permanent-input');

        let thoughts = [];
        let activeParent = null;
        let isPanning = false;
        let panX = 0, panY = 0, scale = 1;
        let startX = 0, startY = 0;

        // --- Core Functions ---
        function createThought(text, x, y, parent = null) {
            const nodeElement = document.createElement('thought-node');
            nodeElement.textContent = text;
            nodeElement.style.left = `${x}px`;
            nodeElement.style.top = `${y}px`;

            const thought = { 
                element: nodeElement, 
                parent: parent, 
                children: [],
                x: x, y: y, 
                width: 0, height: 0
            };
            nodeElement.thought = thought; 
            thoughts.push(thought);

            if (parent) {
                parent.children.push(thought);
                if (parent.children.length === 1) {
                    parent.element.classList.add('expanded');
                }
            } else {
                nodeElement.classList.add('main-thought');
            }

            thoughtContainer.appendChild(nodeElement);
            
            requestAnimationFrame(() => {
                thought.width = nodeElement.offsetWidth;
                thought.height = nodeElement.offsetHeight;
                updateLines();
            });

            nodeElement.addEventListener('click', (e) => {
                e.stopPropagation();
                activeParent = thought;
                promptForNewThought(thought);
            });

            return thought;
        }

        function promptForNewThought(parentThought) {
            const GOLDEN_ANGLE = 137.5 * (Math.PI / 180);
            const BASE_RADIUS = 150;
            // FIX: Increased buffer for better spacing.
            const VISUAL_BUFFER = 40;
            let angle = parentThought.children.length * GOLDEN_ANGLE;
            let radius = BASE_RADIUS;
            let foundPosition = false;
            let newX, newY;

            while (!foundPosition) {
                newX = parentThought.x + parentThought.width / 2 + Math.cos(angle) * radius;
                newY = parentThought.y + parentThought.height / 2 + Math.sin(angle) * radius;

                // FIX: Use a more realistic, larger box for collision checking.
                const nodeWidthEstimate = 150;
                const nodeHeightEstimate = 50;
                const potentialRect = {
                    left: newX - (nodeWidthEstimate / 2),
                    top: newY - (nodeHeightEstimate / 2),
                    right: newX + (nodeWidthEstimate / 2),
                    bottom: newY + (nodeHeightEstimate / 2)
                };

                let overlaps = thoughts.some(t => {
                    const existingRect = {
                        left: t.x - VISUAL_BUFFER,
                        top: t.y - VISUAL_BUFFER,
                        right: t.x + t.width + VISUAL_BUFFER,
                        bottom: t.y + t.height + VISUAL_BUFFER
                    };
                    return !(
                        potentialRect.right < existingRect.left ||
                        potentialRect.left > existingRect.right ||
                        potentialRect.bottom < existingRect.top ||
                        potentialRect.top > existingRect.bottom
                    );
                });

                if (!overlaps) {
                    foundPosition = true;
                } else {
                    radius += 20; 
                    angle += 0.5; // Rotate angle to find next spot
                }
            }
            showInput(newX - 75, newY - 25); // Adjust for input field size
        }

        function showInput(x, y) {
            input.style.display = 'block';
            input.style.left = `${x * scale + panX}px`;
            input.style.top = `${y * scale + panY}px`;
            input.style.transform = `scale(${scale})`;
            input.focus();
        }

        function hideInputAndSave() {
            const text = input.value.trim();
            const worldX = (parseInt(input.style.left, 10) - panX) / scale;
            const worldY = (parseInt(input.style.top, 10) - panY) / scale;

            if (text && activeParent) {
                createThought(text, worldX, worldY, activeParent);
            } else if (text && thoughts.length === 0) {
                 createThought(text, worldX, worldY, null);
            }
            input.style.display = 'none';
            input.value = '';
        }
        
        function updateLines() {
            lineContainer.innerHTML = '';
            const svgNS = 'http://www.w3.org/2000/svg';
            for (const thought of thoughts) {
                if (thought.parent) {
                    const parentEl = thought.parent.element;
                    const childEl = thought.element;
                    const path = document.createElementNS(svgNS, 'path');
                    const x1 = parentEl.offsetLeft + parentEl.offsetWidth / 2;
                    const y1 = parentEl.offsetTop + parentEl.offsetHeight / 2;
                    const x2 = childEl.offsetLeft + childEl.offsetWidth / 2;
                    const y2 = childEl.offsetTop + childEl.offsetHeight / 2;
                    path.setAttribute('d', `M${x1},${y1} L${x2},${y2}`);
                    path.setAttribute('class', thought.children.length > 0 ? 'line--parent-parent' : 'line--parent-sub');
                    lineContainer.appendChild(path);
                }
            }
        }

        function applyTransform() {
            const transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            thoughtContainer.style.transform = transform;
            lineContainer.style.transform = transform;
        }

        // --- Event Listeners ---
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scaleAmount = -0.001;
            const mouseX = e.clientX;
            const mouseY = e.clientY;
            const oldScale = scale;
            scale += e.deltaY * scaleAmount;
            scale = Math.min(Math.max(0.2, scale), 3); // Clamp scale
            panX = mouseX - (mouseX - panX) * (scale / oldScale);
            panY = mouseY - (mouseY - panY) * (scale / oldScale);
            applyTransform();
        });

        canvas.addEventListener('mousedown', (e) => {
            if (e.target !== canvas) return;
            isPanning = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                panX = e.clientX - startX;
                panY = e.clientY - startY;
                applyTransform();
            }
        });

        canvas.addEventListener('mouseup', () => { isPanning = false; canvas.style.cursor = 'grab'; });
        canvas.addEventListener('mouseleave', () => { isPanning = false; canvas.style.cursor = 'grab'; });

        input.addEventListener('keydown', (e) => { if (e.key === 'Enter') hideInputAndSave(); });
        input.addEventListener('blur', hideInputAndSave);

        // --- Initialisation ---
        function start() {
             const initialX = (window.innerWidth / 2) / scale - 75;
             const initialY = (window.innerHeight / 2) / scale - 20;
             activeParent = null;
             showInput(initialX, initialY);
        }

        start();

    </script>
</body>
</html>
